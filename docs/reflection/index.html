<html>
  <head>
    <title>FormulaForge</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Source+Sans+3:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <nav>
      <a class="logo-link" href="/formula-editor">
        <div class="logo"></div>
      </a>
      <ul>
        <li><a href="/formula-editor">Home</a></li>
        <li class="current">
          <a href="/formula-editor/reflection">Reflection</a>
        </li>
        <li><a href="/formula-editor/forge/">Try It!</a></li>
      </ul>
    </nav>
    <article class="reflection">
      <section>
        <h1 class="title">Reflection</h1>
        <img class="hero" src="../assets/formula_forge.png" />
      </section>
      <section>
        <p>
          Equation editing can be a headache, especially when existing tools
          make the workflow frustrating and slow. To address this pain point, we
          designed FormulaForge - a better way to customize formulas.
        </p>

        <p>
          Authors of mathematical content such as researchers, lecturers, and
          students oftentimes need to present that content as formulas, and even
          need to augment those formulas to make them more comprehensible.
          Augmentations are edits such as applying colors or adding boxes.
        </p>

        <p>
          While current solutions, such as Overleaf and Powerpoint, allow you to
          insert... (continue issues with current solutions)
        </p>

        <p>
          In order to address this problem of formula augmentation, we went
          through a design process. We interviewed our target users, compared
          two low fidelity prototypes, interviewed users with a high fidelity
          prototype, performed an experiment, and finally implemented a design
          around user response.
        </p>

        <h2>Initial Interviews</h2>
        <p>
          To understand how prospective users currently modify formulas, we
          spoke to 6 academic users - lecturers, educational YouTubers, and
          researchers.
        </p>
        <h3>Research Goals</h3>
        <ul>
          <li>
            What techniques do participants incorporate in their presentations?
            <ul>
              <li>Spacing/Alignment</li>
              <li>
                Augmentation/Annotations (color, bounding boxes, arrows &amp;
                text boxes, etc.)
              </li>
              <li>Animation, transitions</li>
              <li>Visualization</li>
            </ul>
          </li>
          <li>
            Are there techniques that they aren't incorporating because doing so
            seems arduous?
          </li>
          <li>
            What frustrations or workflow annoyances do they experience when
            trying to create presentations?
          </li>
          <li>How important are visualizations?</li>
        </ul>

        <h3>Interview Guide</h3>
        <ul>
          <li>
            Pre-screening: we should confirm with potential participants ahead
            of time that they've tried to make screen-based presentations of
            formulas before.
          </li>
          <li>
            In what capacity do you need to present formulas? e.g. presenting
            research at conferences, delivering lectures to university
            undergraduates
          </li>
          <li>
            Do you have any materials you've prepared in the past that you can
            share with us? Ask them to walk through some of the presentation
            that's focused on a particular formula. They don't have to (and
            shouldn't) walk through the entire lecture.
          </li>
          <li>
            How do you get formulas into your presentations? e.g. screenshot of
            LaTeX, Powerpoint/Keynote equation editor
          </li>
          <li>
            Once a formula is in your presentation, do you ever need to change
            its formatting?
            <ul>
              <li>
                For this specific presentation, do you ever revisit it? When
                have you done so, and what have you changed?
              </li>
              <li>
                How much time do you put into edits? e.g. for lecture slides, do
                they revisit it yearly when prepping for the class?
              </li>
            </ul>
          </li>
          <li>
            What's your process for editing these presentations? Do you work
            from beginning to end, out of order, something else? Do you ever
            revisit slides to revise them?
          </li>
        </ul>

        <h3>Findings</h3>
        <p>
          We found that they used several different platforms to create content,
          but all preferred LaTex for writing math content. They also shared
          their own struggles with formatting equations, which became
          inspiration for features to add to FormulaForge. For example, one
          interview shared how recompiling their editor took 10 seconds just to
          see one change, which slowed down their thinking and note taking loop.
          Additionally, users discussed how it was difficult to change existing
          LaTex code, especially when the formulas were long. Overall, there
          seemed to be a need and a want for the application we set to make: a
          way to make math equation editing easier.
        </p>
      </section>
      <section>
        <h2>Low Fidelity Prototypes</h2>
        <p>
          With several recurring issues among interviewees, we set out to create
          a platform that would resolve as many of them as possible. The first
          of two possible solutions focused on making a slideshow editor that
          supported formula augmentation, defining formulas / recurring terms,
          and slide grouping. The other solution focused on formula
          manipulation: changing spacing, alignment, as well as changing which
          term the formula was grouped by.
        </p>
        <p>
          Both evaluators mentioned potentially combining the two prototypes: a
          high-level editor for presentation content with a good interactive
          component for making specific layout/augmentation edits to specific
          formulas. We decided to synthesize a new prototype combining aspects
          of both prototypes while also reworking the &ldquo;content
          outline&rdquo; to instead be a &ldquo;content planning&rdquo; canvas
          that mimics a pen-and-paper experience. The canvas-based presentation
          is also motivated by our formative study, which showed that some users
          plan their content on pen and paper before manually transferring it to
          a slide editor.
        </p>
        <p>
          We envisioned an editor with an infinite canvas that can be
          interactively panned/zoomed. Users can quickly add/edit formulas by
          double clicking on empty space or existing formulas, respectively.
          Interactive features for laying out formulas are retained from the
          &ldquo;Layout Editor&rdquo; prototype, enabling quick typesetting.
          Users can copy and paste typeset formulas from the canvas into their
          preferred slide editing software to construct their actual
          presentation.
        </p>
        <img src="../assets/content_planner.png" />
        <img src="../assets/align_editor.png" />
        <img src="../assets/layout_editor.png" />
      </section>
      <section>
        <h2>High Fidelity Prototypes</h2>
        <p>
          After further brainstorming and consideration of our time constraints,
          we decided to focus on an editor for a single LaTex formula, rather
          than a workspace for several formulas and text boxes. With this in
          mind, we created a style guide and mood board to solidify the theme
          and feel of our platform. After that was completed, we created a high
          fidelity prototype on Figma.
        </p>
        <p>
          Our prototype demonstrated being able to add a function in LaTex,
          select terms, change the color of variables, box terms, and further
          edit the LaTex code. We then completed several heuristic evaluations.
        </p>
        <p>
          When prompted for first impressions, the universal response was “it’s
          pretty cool”. Overall, users seemed to be pleased with the interactive
          editing process and found this to be easier than alternatives for
          applying the sort of formula customizations/augmentations that our
          editor supports.
        </p>
        <p>
          The most clear problem identified in the user interviews (and
          foreshadowed by our heuristic evaluators) was in selecting terms to
          apply augmentations to. Users had different expectations on what their
          initial click should select, what clicking on the same selection
          multiple times would do, and how they could most effectively make a
          required selection. This can mostly be attributed to the limitations
          in prototyping on Figma, but it reinforces the need for diverse
          selection mechanisms that make selections at any level of granularity
          convenient.
        </p>
        <p>
          Users were also unanimously confused with the content/presentation
          separation that we enforce by not showing augmentations in the LaTeX
          code. One user asked to be shown the complete LaTeX code including all
          augmentations so that they could better interpret the effects of their
          manipulations via the interface. They also tried to add augmentations
          by typing them as LaTeX code. Users also stressed that they wanted to
          be able to import/export equations to/from our editor (as SVG/PDF or
          LaTeX code) as quickly as possible, as this editor is but a component
          in their broader presentation-editing workflow.
        </p>
        <p>
          With this feedback, we modified our high fidelity prototype and
          prepared to create a fully interactive prototype.
        </p>
        <img src="../assets/moodboard.png" />
        <img src="../assets/style_guide.png" />
        <img src="../assets/storyboard.png" />
        <img src="../assets/hifi.png" />
      </section>
      <section>
        <h2>Implementation</h2>
        <p>
          In order to support bidirectional editing between the code pane and
          canvas pane, we need an intermediate representation that mediates
          changes between the two formats. In order to support LaTeX code import
          and content changes in the code pane, we must be able to parse LaTeX
          code into the intermediate representation. In order to respond to
          interactions made in the canvas pane, we must be able to associate
          actions performed in the canvas pane to transformations on the
          intermediate representation. In order to rerender the canvas pane in
          response to changes, we must be able to convert the intermediate
          representation into an input format understood by a math rendering
          engine. We call this intermediate representation MathMetal.
        </p>
        <p>
          <strong>MathMetal format</strong>: MathMetal is a tree-based
          representation of a mathematical formula. Each non-leaf node in the
          tree represents a group with some properties, e.g. a
          <code>color</code> node's children all get the same text color. Each
          leaf node in the tree represents a single symbol such as
          &ldquo;&alpha;&rdquo; or &ldquo;2&rdquo;.
        </p>
        <p>
          <strong>Parsing LaTeX to MathMetal</strong>: The initial MathMetal
          tree is constructed by first parsing input LaTeX to an AST. However,
          MathMetal is not a 1-to-1 match with the LaTeX AST. Instead, the AST
          is transformed into an equivalent structure that can still be
          serialized to obtain the same LaTeX code. Transforming the AST
          structure gives an opportunity to add or remove nodes where
          appropriate to make the structure more convenient when writing code to
          implement our direct manipulation transformations. For example, the
          LaTeX AST considers multiple sequential digits to sibling symbols
          under the same parent. For our purposes, it's much more convenient to
          consider them as a number, so we introduce a common parent node whose
          children are each of the individual digits.
        </p>
        <p>
          <strong>Rendering Formulas from MathMetal</strong>: A \repr~ tree can
          always be serialized to \LaTeX. Each node type implements a
          \texttt{toLatex()} method responsible for converting it and its
          children to \LaTeX. For example, a \texttt{group} node represents a
          scope in \LaTeX wrapped with curly braces and produces \LaTeX~ by
          recursively calling \texttt{toLatex()} on each of its children,
          concatenating them, and surrounding them with \texttt{\{\}}. After
          serializing the tree to \LaTeX, the formula can be rendered using any
          conventional \LaTeX~ math rendering engine.
        </p>
        <p>
          <strong>Mapping Interactions to MathMetal</strong>: If we only needed
          to render LaTeX to the visual formula input, we would not need
          MathMetal at all, as we could simply. Thus, the entire reason for
          creating and maintaining this representation is to allow changes to
          propagate in the other direction, from the canvas pane to the code
          pane. In truth, we also rely on this representation in order to
          implement the direct manipulation transformations: rather than
          implement the necessary visual changes by ourselves, we simply
          serialize the MathMetal tree to LaTeX and rely on the math rendering
          engine to do the work for us. This also ensures that the output is as
          close as possible to what the user will see when they export the LaTeX
          code to their presentation environment.
        </p>

        <p>
          In order to enable interactivity, we need to allow the user to select
          symbols (and thus we need to know where those symbols are located on
          the screen). When those symbols are selected, we need to know which
          nodes of the MathMetal tree they map to. We achieve this using
          MathJax's
          <code>\cssId</code> macro, which does not affect the visual result of
          the rendered formula, but applies <code>id</code> attributes to the
          enclosing DOM elements for each symbol in the rendered HTML, allowing
          us to target them using normal DOM APIs. When constructing the
          MathMetal tree on initial parse, we assign a unique ID to each node.
          When serializing MathMetal to LaTeX, each node's LaTeX code is wrapped
          with <code>\cssId{nodeId}{...}</code>. After rendering the formula to
          the DOM, we can extract bounding boxes for each symbol by locating the
          relevant DOM node via its ID and measure it. This is also useful for
          implementing selection coalescing, as the rendering engine creates
          parent DOM nodes for groups of symbols that enclose the individual
          symbol. Thus, the parent's bounding box encloses all of the contained
          symbols.
        </p>

        <p>
          Direct manipulation transformations are implemented as transformations
          of the MathMetal tree. While we initially expected this to be
          straightforward, the necessary tree manipulations can be surprisingly
          complex. For example, adding color to a symbol is as simple as
          locating the node within the tree and wrapping it with a parent
          <code>color</code> node. However, if we were to always apply this
          transformation every time the user applied a color to this symbol, we
          would grow a chain of useless <code>color</code> nodes, of which only
          the lowest one would actually render. This is not <em>incorrect</em>,
          but it clutters the code pane and makes the eventually exported LaTeX
          code more unwieldy. Thus, we must look for if the target node already
          has a <code>color</code> node as its parent and, if it exists, simply
          change the color of that node. But even this is too simple! There may
          be other styling nodes applying to this same node. For example, what
          if we were to alternately apply colors and font styles to the same
          selected node? We could now instead grow a chain of alternating color
          and font nodes. Thus, we must search the node's ancestors for relevant
          <code>color</code> nodes, stopping if we ever encounter a node that
          has more than one child (because any ancestor <code>color</code> nodes
          would instead apply to more than just the selected node). If we find
          such a node, we can change its color, otherwise we must introduce a
          new <code>color</code> node. Similar (but not exactly the same)
          situations apply to all manipulations that we want to apply to
          formulas.
        </p>
        <p>
          <strong>Editing Code of Augmented Formulas</strong>: Since MathMetal
          is the source of truth about the current augmented formula state, and
          since MathMetal can be serialized to and parsed from LaTeX, changes
          made to the LaTeX code in the code pane can be seen as transformations
          of MathMetal. As the user performs direct manipulation interactions in
          the canvas pane, the code pane is constantly updated with the most
          recent LaTeX corresponding to the current MathMetal tree. Thus, to
          support edits from the code pane propagating to the canvas pane, we
          need only parse the LaTeX code into MathMetal as the user edits the
          code and render the formula.
        </p>
      </section>
      <section>
        <h2>Experiment</h2>
        <p>
          To further refine our platform for an optimal user experience, we
          created an experiment to test two types of menus.
        </p>

        <p>
          <strong>Design Question</strong>: What menu should we give to help
          users complete tasks quickly and comfortably?
        </p>
        <p>
          <strong>Independent Variable</strong>: Constant menu bar on top of
          page vs. smaller menu bar that pops up when user right-clicks.
        </p>
        <p>
          <strong>Task</strong>: Replicate a screenshot of one colored formula,
          utilizing the selection feature and the menu’s font color option.
          Users will complete the task with both menu styles, randomly assigning
          the colored formula screenshot they need to replicate, as well as the
          order of menu styles.
        </p>
        <p>Screenshot 1:<img src="../assets/study_1.png" /></p>
        <p>Screenshot 2:<img src="../assets/study_2.png" /></p>
        <p>
          <strong>Dependent Variable</strong>: Time taken to complete the tasks,
          as well as perceived menu comfort.
        </p>
        <ul>
          <li>Time taken to complete the tasks, measured with a stopwatch</li>
          <li>
            Perceived menu comfort, measured with a questionnaire
            <ul>
              <li>
                On a scale from 1 to 5, how easy was it to complete the task
                with the menu?
              </li>
              <li>Which menu did you prefer?</li>
            </ul>
          </li>
        </ul>
        <p><strong>Hypotheses:</strong></p>
        <ul>
          <li>After users try both menus, they will prefer the top menu.</li>
          <li>
            Users will complete the task quicker with the pop-up menu than with
            the top menu.
          </li>
        </ul>
        <p>
          <strong>Testing method</strong>: We will conduct t-tests for the data
          on time taken to complete the tasks. We will conduct Wilcoxon
          signed-rank tests to compare the data from the questionnaire.
        </p>
        <p>
          <strong>Method Appropriateness</strong>: The t-test will be used to
          analyze the time taken to complete the task, and to see if the pop-up
          menu is quicker than the top menu. The Wilcoxon signed-rank test will
          be used to analyze the Likert question &ldquo;How easy was it to
          complete the task,&rdquo; where 5 is the easiest. This will help us
          determine if people find the top menu more comfortable/easy to use
          than the pop-up menu.
        </p>
        <p><strong>Statistical Analysis Methods and Results:</strong></p>
        <ul>
          <li>
            Wilcoxon Signed Rank Test: For this test, we used this site
            (suggested by homework description). Treatment 1 was the Likert
            (1-5) data &ldquo;Top Menu Rating,&rdquo; while Treatment 2 was
            &ldquo;RC Menu Rating.&rdquo; We used a significance level of 0.05
            and a two-tailed hypothesis.
            <ul>
              <li>Z-Value: -0.840</li>
              <li>W-Value: 12, with a critical value of 3</li>
              <li>P-Value: 0.401, which is not significant at p&lt;0.05.</li>
              <li>Since n=8, the result is not statistically significant.</li>
            </ul>
          </li>
          <li>
            T-Test: For this test, we used this site (suggested by homework
            description). Treatment 1 was the data in seconds &ldquo;Top Menu
            Time,&rdquo; while Treatment 2 was &ldquo;RC Menu Time.&rdquo; We
            used a significance level of 0.05 and a two-tailed hypothesis.
            <ul>
              <li>T-Value: -1.356</li>
              <li>P-Value: 0.197, which is not significant at p&lt;0.05.</li>
              <li>Since n=8, the result is not statistically significant.</li>
            </ul>
          </li>
        </ul>

        <p>
          <strong>Conclusions</strong>: Since n=8, neither of our tests produced
          statistically significant results. Putting that aside, The
          participants, when receiving the top menu treatment (M=26.875,
          SD=14.545), demonstrated slightly quicker task completion than when
          receiving the right click menu treatment (M=44.625, SD=34.046), with
          t=-1.356, p=0.197. The participants, when asked how easy the task was
          to be completed, only slightly found the top menu (M=3.625, SD=0.518)
          easier than the right click menu (M=3.313, SD=0.923). This test scored
          a W-value of 12 with a critical value of 8, meaning that there is no
          significant difference between the treatments (p=0.401). Thus, it
          seems there is only a slight, statistically insignificant, preference
          towards the top menu bar. Our hypothesis that users will prefer the
          top menu was (slightly) correct. Our hypothesis that the right click
          menu would be quicker was (slightly) incorrect.
        </p>

        <p>
          Given this information, we have determined that we definitely need to
          include the top bar in our final design. And, since the right click
          menu scored similarly to the top menu, we will consider adding it as
          an additional option for users who highly prefer it.
        </p>
      </section>
      <section>
        <h2>Future Work</h2>
        <ul>
          <li>
            <strong>Content-Only Code View</strong>: We would prefer to allow
            users to only see the &ldquo;math content&rdquo; of their formulas
            and omit the styling markup. This should be possible by omitting
            styling-related nodes when serializing the MathMetal tree to LaTeX.
          </li>
          <li>
            <strong>Preserving Code Styling:</strong>: When the MathMetal tree
            is serialized to LaTeX after a direct manipulation, the user's code
            styling (spacing, line breaks, braces) is lost. This can cause users
            to lose track of the code as it unexpectedly changes shape without
            their intervention.
          </li>
          <li>
            <strong>Bidirectional Selections</strong>: If the user wishes to
            edit code relevant to a particular symbol, it may be faster to click
            on that symbol in the rendered formula. This should select the
            corresponding range of code in the code editor.
          </li>
        </ul>
      </section>
      <section>
        <h2>Appendix</h2>
        <ul>
          <li>
            <a href="https://github.com/Speculative/formula-editor">Github</a>
          </li>
          <li>
            <a
              href="https://docs.google.com/presentation/d/1kk0WLIEXsCh4D-8exGv3CZ_x8o3MtibdPyJMKHdf_2E/edit?usp=sharing"
              >Slides</a
            >
          </li>
          <li>
            <a
              href="https://drive.google.com/file/d/1oE1AlMwxUe1aBBbpZIM5lxkqc8WT_0MO/view?usp=sharing"
              >Poster</a
            >
          </li>
        </ul>
      </section>
    </article>
  </body>
</html>
